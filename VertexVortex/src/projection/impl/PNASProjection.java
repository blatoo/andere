package projection.impl;

import java.util.LinkedList;
import projection.abstr.SimplexProjection;
import graph.SimplexGraph;

/**
 * Projection that implements the computation of weights for the "PNAS-paper"
 * for the edges of the projection. Only use with SIMPLEX graphs.
 */
public class PNASProjection extends SimplexProjection {
    /* COMPUTED DATA
     * (this will be generated by the algorithm and does not need to be initialized) */
    public int[][] result;      // structure for storing initial co-occurrences and p-value counts
                                // result[n] contains all co-occurences for actor n with all actors m that have
                                // a higher ID (m > n). If cooc(n,m)=0 there is no entry.
                                // Format is a sequence of triples: (actorID, initial co-occurrence, p-value count)
                                // actorIDs can be found at positions 3i
                                // initial co-occurrences can be found at positions 3i+1
                                // p-value counts are stored at positions 3i+2
    public long[][] coocs;      // structure for storing cooc-sum and cooc square sum for pairs of
                                // actors with initial cooc. Ids are given by the corresponding position in result
                                // cooc sums are stored at positions 2i
                                // cooc square sum are stored at positions 2i+1    
    public int[][] adjmatrix;   // structure for storing the edgecounts in the sampled graphs
                                // adjmatrix[x][y] contains the number of sampled graphs
                                // in which an edge between actor x and event y exists.
    public double[][] cmatrix;  // structure for storing the "centered" adjacency matrix of the graph
                                // will be initialized to contain 1s and 0s according to the original graph
    public double[] norm;       // structure for storing the euclidean norms of all actor-vectors
    
    public PNASProjection(SimplexGraph graph) {
        super(graph);
        this.weightType="PNAS";
    }
    
    /**
     * Initializes the memory needed to store results of the computation
     */
    public void doOnceBeforeSampling() {
        result = new int[g.actorCount][];    // make sure a list for the initial cooc exists
        coocs = new long[g.actorCount][];
        adjmatrix = new int[g.actorCount][g.eventCount];    // create an empty matrix for adjacency counts
        cmatrix = new double[g.actorCount][g.eventCount];   // create an empty adjacency matrix
        for (int a=0; a<g.actorCount; a++) {                // initialize the adjacency matrix so we have:
            for (int e : g.adjList[a]) {                    // edge is realized: 1, not realized: 0
                cmatrix[a][e] = 1;
            }
        }
        norm = new double[g.actorCount];                    // initialize storage for actor vector norms
    }
    
    /**
     * Computes the initial co-occurrences of all actors in the original graph
     */
    public void doPerActorBeforeSampling(int a) {
        LinkedList<Integer> tmpCoocs = new LinkedList<Integer>();   // create a list for new coocs as their number is not known
        for (int b=a+1; b<g.actorCount; b++) {                      // for all actors B with ID higher than a
            int cooc = computeCooc(g.adjList[a], g.adjList[b]);     // compute their co-occurence
            if (cooc > 0) {                                         // if they do co-occur
                tmpCoocs.add(b);                                    // add the ID of actor b to the list
                tmpCoocs.add(cooc);                                 // and add the co-occurence
            }
        }
        /* create an int array that has 2 entries for each cooc of actor a:
         * position i  : counter for observed cooc
         * position i+1: counter for observed cooc squares */
        coocs[a] = new long[tmpCoocs.size()];
        /* create an int array that has 3 entries for each cooc of actor a:
         * position i:   ID of target node
         * position i+1: initial cooc for these two nodes
         * position i+2: p-value counts */
        result[a] = new int[tmpCoocs.size() + tmpCoocs.size()/2];
        int pos = 0;
        while (!tmpCoocs.isEmpty()) {                   // copy actor IDs and coocs from list to array
            result[a][pos++] = tmpCoocs.remove();
            result[a][pos] = tmpCoocs.remove();
            pos += 2;                                   // leave three spaces for observed coocm cooc squares and p-value counts
        }
    }
    
    /**
     * After each new graph is sampled, this computes the co-occurrence for all pairs of nodes with
     * a co-occurrence in the initial graph and adds it to the coocs.
     */
    public void doPerActorDuringSampling(int ac1) {
        int ac2;
        int resPos = 0;
        int coocPos = 0;
        while (resPos < result[ac1].length) {      // go through the lists of initial coocs
            ac2 = (int)result[ac1][resPos++];      // get IDs of target actors
            // compute cooc for this pair of actors and add it to cooc count
            int cooc = computeCooc(g.adjList[ac1], g.adjList[ac2]);
            long initCooc = result[ac1][resPos++];
            if (cooc >= initCooc) result[ac1][resPos]++;
            resPos++;
            coocs[ac1][coocPos++] += cooc;
            coocs[ac1][coocPos++] += cooc*cooc;
        }
        for (int e : g.adjList[ac1]) {         // for all edges incident to this actor
            adjmatrix[ac1][e]++;               // increase edgecounter in adjacency matrix
        }
    }
    
    /**
     * After the computation is complete, finalize the adjacency matrix
     * and compute norm for all actor vectors in adjacency matrix
     */
    public void finalizeAdjacencyMatrix() {
        double samples = g.samples;
        for (int a=0; a<g.actorCount; a++) {
            for (int e=0; e<g.eventCount; e++) {
                cmatrix[a][e] -= adjmatrix[a][e]/samples;
                norm[a] += Math.pow(cmatrix[a][e], 2);
            }
            norm[a] = Math.sqrt(norm[a]);
        }
        
    }
    
}
