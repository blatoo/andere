package projection.impl;

import java.util.LinkedList;

import projection.abstr.SimplexProjection;

import graph.SimplexGraph;

/**
 * Projection that implements the computation of p-values as weights
 * for the edges of the projection. Only use with SIMPLEX graphs.
 */
public class PvalueSimplexProjection extends SimplexProjection {
    /* COMPUTED DATA
     * (this will be generated by the algorithm and does not need to be initialized) */
    public int[][] result;      // structure for storing initial co-occurrences and computed p-value counts
                                // cooc[n] contains all co-occurences for actor n with all actors m that have
                                // a higher ID (m > n). If cooc(n,m)=0 there is no entry.
                                // Format is a sequence of triples: (actorID, initial co-occurrence, p-valueCount)
                                // actorIDs can be found at positions 3i
                                // initial co-occurrences can be found at positions 3i +1
                                // p-value counts are stored at positions 3i +2
    
    public PvalueSimplexProjection(SimplexGraph graph) {
        super(graph);
        this.weightType="pvalue";
    }
    
    /**
     * Initializes the memory needed to store results of the computation
     */
    public void doOnceBeforeSampling() {
        result = new int[g.actorCount][];    // make sure a list for the initial cooc exists
    }
    
    /**
     * Computes the initial co-occurrences of all actors in the original graph
     */
    public void doPerActorBeforeSampling(int a) {
        LinkedList<Integer> tmpCoocs = new LinkedList<Integer>();   // create a list for new coocs as their number is not known
        for (int b=a+1; b<g.actorCount; b++) {                      // for all actors B with ID higher than a
            int cooc = computeCooc(g.adjList[a], g.adjList[b]);     // compute their co-occurence
            if (cooc > 0) {                                         // if they do co-occur
                tmpCoocs.add(b);                                    // add the ID of actor b to the list
                tmpCoocs.add(cooc);                                 // and add the co-occurence
            }
        }
        /* create an int array that has 3 entries for each cooc of actor a:
         * position i:   ID of target node
         * position i+1: initial cooc for these two nodes
         * position i+2: counter for observed cooc */
        result[a] = new int[tmpCoocs.size() + tmpCoocs.size()/2];
        int pos = 0;
        while (!tmpCoocs.isEmpty()) {                   // copy actor IDs and coocs from list to array
            result[a][pos++] = tmpCoocs.remove();
            result[a][pos] = tmpCoocs.remove();
            pos += 2;                                   // leave one space for observed cooc
        }
    }
    
    /**
     * After each new graph is sampled, this checks for each co-occurrence of two nodes in the
     * original graph, if the p-value count for this edge should be increased.
     */
    public void doPerActorDuringSampling(int ac1) {
        int ac2;
        int coocPos = 0;
        while (coocPos < result[ac1].length) {      // go through the lists of initial coocs
            ac2 = result[ac1][coocPos];             // get IDs of target actors
            coocPos++;
            int cooc = computeCooc(g.adjList[ac1], g.adjList[ac2]);
            // compute cooc for this pair of actors. If it is larger than initial cooc: increment counter
            if (cooc >= result[ac1][coocPos]) {
                coocPos++;
                result[ac1][coocPos]++;
                coocPos++;
            } else coocPos += 2;
        }
    }
    
}
