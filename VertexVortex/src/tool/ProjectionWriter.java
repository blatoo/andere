/*  Copyright (c) 2012  Andreas Spitz, spitz@stud.uni-heidelberg.de
 *
 *  This file is part of VertexVortex
 *
 *  VertexVortex is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  VertexVortex is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package tool;

import graph.DuplexGraph;
import graph.Graph;
import graph.SimplexGraph;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashSet;
import java.util.Locale;

import projection.impl.AllDuplexProjection;
import projection.impl.AllSimplexProjection;
import projection.impl.LeverageDuplexProjection;
import projection.impl.LeverageSimplexProjection;
import projection.impl.PNASProjection;
import projection.impl.PvalueDuplexProjection;
import projection.impl.PvalueSimplexProjection;

/**
 * Class used to write computed data to file
 */
public class ProjectionWriter {
    private static final String sourceFile = "Source-File";
    private static final String time = "Date";
    private static final String samples = "Samples";
    private static final String steps = "Steps";
    private static final String seed = "Random seed";
    private static final String type = "Projection type";
    private static final String finalized = "Finalized";
    private static final String side = "Projection side";
    private static final String decPrecision = "Decimal precision";
    private static final String weights = "Type of weights";

    /**
     * Write computed data to file
     * @param file output file handle
     * @param g graph containing computed data
     * @param finalize create p-values by dividing p-value count / samples (true) or print p-value counts (false)
     * @throws Exception
     */
    public static void writeResults(File file, Graph g, boolean finalize, String programVersion, int precision) throws Exception {
        BufferedWriter output = new BufferedWriter(new FileWriter(file));
        
        // create decimal format according to the number of decimal places set by the user
        if (precision < 1) precision = 1;                       // no less than one decimal place
        if (precision > 14) precision = 14;                     // but no more than 14
        String precFormat = "0.0";
        for (int i=1; i<precision; i++) precFormat += "#";
        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);
        symbols.setInfinity("Inf");
        symbols.setNaN("NaN");
        DecimalFormat df = new DecimalFormat(precFormat, symbols);
        
        // write header comment
        output.append("#One-mode projection data generated by " + programVersion + "\n");
        output.append("#" + type + ((g.isSimplex) ? ": simplex" : ": duplex") + "\n");
        output.append("#" + weights + ": " + g.projection.weightType + "\n");
        if (g.projection.weightType.equals("PNAS")) {
            output.append("#" + finalized + ": true\n");            // PNAS does not support temporary results
        } else {
            output.append("#" + finalized + ": " + finalize + "\n");
        }
        output.append("#" + sourceFile + ": " + g.name + "\n");
        output.append("#" + time + ": " + new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date()) +"\n");
        output.append("#" + side + ": " + g.side + "\n");
        output.append("#" + samples + ": " + g.samples + "\n");
        output.append("#" + steps + ": " + g.steps + "\n");
        output.append("#" + seed + ": " + g.randomSeed + "\n");
        output.append("#" + decPrecision + ": " + precision + "\n");
        
        
        // write actual data to file
        if (g.isSimplex) {
            if (g.projection.weightType.equals("pvalue")) {
                writeSimplexPvalueProjection(output, (SimplexGraph)g, finalize, df);
            } else if (g.projection.weightType.equals("leverage")) {
                writeSimplexLeverageProjection(output, (SimplexGraph)g, finalize, df);
            } else if (g.projection.weightType.equals("all")) {
                writeSimplexAllProjection(output, (SimplexGraph)g, finalize, df);
            } else if (g.projection.weightType.equals("PNAS")) {
                writeSimplexPNASProjection(output, (SimplexGraph)g, finalize, df);
            } else {
                System.out.println("Unknown projection type " + g.projection.weightType + ". Unable to write to file.");
            }
        } else {
            if (g.projection.weightType.equals("pvalue")) {
                writeDuplexPvalueProjection(output, (DuplexGraph)g, finalize, df);
            } else if (g.projection.weightType.equals("leverage")) {
                writeDuplexLeverageProjection(output, (DuplexGraph)g, finalize, df);
            } else if (g.projection.weightType.equals("all")) {
                writeDuplexAllProjection(output, (DuplexGraph)g, finalize, df);
            } else if (g.projection.weightType.equals("PNAS")) {
                System.out.println("There is no duplex projection for PNAS weights. Unable to write to file.");
            } else {
                System.out.println("Unknown projection type " + g.projection.weightType + ". Unable to write to file.");
            }
        }
        
        output.close();
    }
    
    private static void writeSimplexAllProjection(BufferedWriter output, SimplexGraph g, boolean finalize, DecimalFormat df) throws Exception {
        AllSimplexProjection proj = (AllSimplexProjection)g.projection;
        if (finalize) {
            output.append("id1 id2 sim cos cooc lev lift pvalue zscore smin smax sav deg1 deg2\n");
            for (int ac1 = 0; ac1 < g.actorCount; ac1++) {                        // for all actor nodes
                int r = 0;                                                        // start at the beginning of their cooc list
                int c = 0;
                while (r < proj.result[ac1].length) {                             // and while its end is not reached
                    int ac2 = (int)proj.result[ac1][r++];
                    int initCooc = proj.result[ac1][r++];
                    double pvalue = ((double)(proj.result[ac1][r++]))/g.samples;  // compute p-value
                    long coocSum = proj.coocs[ac1][c++];
                    long coocSquares = proj.coocs[ac1][c++];
                    int deg1 = g.degrees[ac1];
                    int deg2 = g.degrees[ac2];
                    
                    double sim = (initCooc*g.eventCount - deg1*deg2)/Math.pow(g.eventCount, 2);
                    double expCooc = ((double)(coocSum))/g.samples;
                    double lev = (double)initCooc - expCooc;
                    double lift = (double)initCooc / expCooc;
                    double zscore = lev/Math.sqrt( ((double)coocSquares)/g.samples - Math.pow(expCooc,2) );
                    double smin = lev/Math.min(deg1, deg2);
                    double smax = lev/Math.max(deg1, deg2);
                    double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                    double sav = lev/degProduct;
                    double cos = initCooc/degProduct;
                    
                    output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " ");
                    output.append(df.format(sim)+" "+df.format(cos)+" "+initCooc+" "+df.format(lev)+" "+df.format(lift)+" "+df.format(pvalue)+" "+df.format(zscore)+" "+df.format(smin)+" "+df.format(smax)+" "+df.format(sav)+" "+deg1+" "+deg2+"\n");
                }
            }
        }
        else {
            output.append("id1 id2 sim cos init_cooc cooc_count cooc_squares pvalue_count deg1 deg2\n");
            for (int ac1 = 0; ac1 < g.actorCount; ac1++) {                        // for all actor nodes
                int r = 0;                                                        // start at the beginning of their cooc list
                int c = 0;
                while (r < proj.result[ac1].length) {                             // and while its end is not reached
                    int ac2 = (int)proj.result[ac1][r++];
                    int initCooc = proj.result[ac1][r++];
                    int pvalCount = proj.result[ac1][r++];
                    long coocSum = proj.coocs[ac1][c++];
                    long coocSquares = proj.coocs[ac1][c++];
                    int deg1 = g.degrees[ac1];
                    int deg2 = g.degrees[ac2];
                    
                    double sim = (initCooc*g.eventCount - deg1*deg2)/Math.pow(g.eventCount, 2);
                    double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                    double cos = initCooc/degProduct;
                    
                    output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " ");
                    output.append(sim + " " + cos + " " + initCooc + " " + coocSum + " " + coocSquares + " " + pvalCount + " " + deg1 + " " + deg2 + "\n");
                }
            }
        }
    }
    
    private static void writeDuplexAllProjection(BufferedWriter output, DuplexGraph g, boolean finalize, DecimalFormat df) throws Exception {
        AllDuplexProjection proj = (AllDuplexProjection)g.projection;
        if (finalize) {
            output.append("id1 id2 type sim cos cooc lev lift pvalue zscore smin smax sav deg1 deg2\n");
            for (int ac1 = 0; ac1 < g.actorCount; ac1++) {                        // for all actor nodes
                int r = 0;                                                        // start at the beginning of their cooc list
                int c = 0;
                while (r < proj.resultPos[ac1].length) {                             // and while its end is not reached
                    int ac2 = (int)proj.resultPos[ac1][r++];
                    int initCooc = proj.resultPos[ac1][r++];
                    double pvalue = ((double)(proj.resultPos[ac1][r++]))/g.samples;  // compute p-value
                    long coocSum = proj.coocPos[ac1][c++];
                    long coocSquares = proj.coocPos[ac1][c++];
                    int deg1 = g.degreesPos[ac1];
                    int deg2 = g.degreesPos[ac2];
                    
                    double sim = (initCooc*g.eventCount - deg1*deg2)/Math.pow(g.eventCount, 2);
                    double expCooc = ((double)(coocSum))/g.samples;
                    double lev = (double)initCooc - expCooc;
                    double lift = (double)initCooc / expCooc;
                    double zscore = lev/Math.sqrt( ((double)coocSquares)/g.samples - Math.pow(expCooc,2) );
                    double smin = lev/Math.min(deg1, deg2);
                    double smax = lev/Math.max(deg1, deg2);
                    double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                    double sav = lev/degProduct;
                    double cos = initCooc/degProduct;
                    
                    output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " ++ ");
                    output.append(df.format(sim)+" "+df.format(cos)+" "+initCooc+" "+df.format(lev)+" "+df.format(lift)+" "+df.format(pvalue)+" "+df.format(zscore)+" "+df.format(smin)+" "+df.format(smax)+" "+df.format(sav)+" "+deg1+" "+deg2+"\n");
                }
                r = 0;                                                        // start at the beginning of their cooc list
                c = 0;
                while (r < proj.resultNeg[ac1].length) {                             // and while its end is not reached
                    int ac2 = (int)proj.resultNeg[ac1][r++];
                    int initCooc = proj.resultNeg[ac1][r++];
                    double pvalue = ((double)(proj.resultNeg[ac1][r++]))/g.samples;  // compute p-value
                    long coocSum = proj.coocNeg[ac1][c++];
                    long coocSquares = proj.coocNeg[ac1][c++];
                    int deg1 = g.degreesNeg[ac1];
                    int deg2 = g.degreesNeg[ac2];
                    
                    double sim = (initCooc*g.eventCount - deg1*deg2)/Math.pow(g.eventCount, 2);
                    double expCooc = ((double)(coocSum))/g.samples;
                    double lev = (double)initCooc - expCooc;
                    double lift = (double)initCooc / expCooc;
                    double zscore = lev/Math.sqrt( ((double)coocSquares)/g.samples - Math.pow(expCooc,2) );
                    double smin = lev/Math.min(deg1, deg2);
                    double smax = lev/Math.max(deg1, deg2);
                    double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                    double sav = lev/degProduct;
                    double cos = initCooc/degProduct;
                   
                    output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " -- ");
                    output.append(df.format(sim)+" "+df.format(cos)+" "+initCooc+" "+df.format(lev)+" "+df.format(lift)+" "+df.format(pvalue)+" "+df.format(zscore)+" "+df.format(smin)+" "+df.format(smax)+" "+df.format(sav)+" "+deg1+" "+deg2+"\n");
                }
                r = 0;                                                        // start at the beginning of their cooc list
                c = 0;
                while (r < proj.resultMix[ac1].length) {                             // and while its end is not reached
                    int ac2 = (int)proj.resultMix[ac1][r++];
                    int initCooc = proj.resultMix[ac1][r++];
                    double pvalue = ((double)(proj.resultMix[ac1][r++]))/g.samples;  // compute p-value
                    long coocSum = proj.coocMix[ac1][c++];
                    long coocSquares = proj.coocMix[ac1][c++];
                    int deg1 = g.degreesNeg[ac1];
                    int deg2 = g.degreesPos[ac2];
                    
                    double sim = (initCooc*g.eventCount - deg1*deg2)/Math.pow(g.eventCount, 2);
                    double expCooc = ((double)(coocSum))/g.samples;
                    double lev = (double)initCooc - expCooc;
                    double lift = (double)initCooc / expCooc;
                    double zscore = lev/Math.sqrt( ((double)coocSquares)/g.samples - Math.pow(expCooc,2) );
                    double smin = lev/Math.min(deg1, deg2);
                    double smax = lev/Math.max(deg1, deg2);
                    double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                    double sav = lev/degProduct;
                    double cos = initCooc/degProduct;
                    
                    output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " -+ ");
                    output.append(df.format(sim)+" "+df.format(cos)+" "+initCooc+" "+df.format(lev)+" "+df.format(lift)+" "+df.format(pvalue)+" "+df.format(zscore)+" "+df.format(smin)+" "+df.format(smax)+" "+df.format(sav)+" "+deg1+" "+deg2+"\n");
                }
            }
        }
        else {
            output.append("id1 id2 type sim cos init_cooc cooc_count cooc_squares pvalue_count deg1 deg2\n");
            for (int ac1 = 0; ac1 < g.actorCount; ac1++) {                        // for all actor nodes
                int r = 0;                                                        // start at the beginning of their cooc list
                int c = 0;
                while (r < proj.resultPos[ac1].length) {                             // and while its end is not reached
                    int ac2 = (int)proj.resultPos[ac1][r++];
                    int initCooc = proj.resultPos[ac1][r++];
                    int pvalCount = proj.resultPos[ac1][r++];
                    long coocSum = proj.coocPos[ac1][c++];
                    long coocSquares = proj.coocPos[ac1][c++];
                    int deg1 = g.degreesPos[ac1];
                    int deg2 = g.degreesPos[ac2];
                   
                    double sim = (initCooc*g.eventCount - deg1*deg2)/Math.pow(g.eventCount, 2);
                    double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                    double cos = initCooc/degProduct;
                    
                    output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " ++ ");
                    output.append(sim + " " + cos + " " + initCooc + " " + coocSum + " " + coocSquares + " " + pvalCount + " " + deg1 + " " + deg2 + "\n");
                }
                r = 0;                                                        // start at the beginning of their cooc list
                c = 0;
                while (r < proj.resultNeg[ac1].length) {                             // and while its end is not reached
                    int ac2 = (int)proj.resultNeg[ac1][r++];
                    int initCooc = proj.resultNeg[ac1][r++];
                    int pvalCount = proj.resultNeg[ac1][r++];
                    long coocSum = proj.coocNeg[ac1][c++];
                    long coocSquares = proj.coocNeg[ac1][c++];
                    int deg1 = g.degreesNeg[ac1];
                    int deg2 = g.degreesNeg[ac2];
                    
                    double sim = (initCooc*g.eventCount - deg1*deg2)/Math.pow(g.eventCount, 2);
                    double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                    double cos = initCooc/degProduct;
                    
                    output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " -- ");
                    output.append(sim + " " + cos + " " + initCooc + " " + coocSum + " " + coocSquares + " " + pvalCount + " " + deg1 + " " + deg2 + "\n");
                }
                r = 0;                                                        // start at the beginning of their cooc list
                c = 0;
                while (r < proj.resultMix[ac1].length) {                             // and while its end is not reached
                    int ac2 = (int)proj.resultMix[ac1][r++];
                    int initCooc = proj.resultMix[ac1][r++];
                    int pvalCount = proj.resultMix[ac1][r++];
                    long coocSum = proj.coocMix[ac1][c++];
                    long coocSquares = proj.coocMix[ac1][c++];
                    int deg1 = g.degreesNeg[ac1];
                    int deg2 = g.degreesPos[ac2];
                    
                    double sim = (initCooc*g.eventCount - deg1*deg2)/Math.pow(g.eventCount, 2);
                    double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                    double cos = initCooc/degProduct;
                   
                    output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " -+ ");
                    output.append(sim + " " + cos + " " + initCooc + " " + coocSum + " " + coocSquares + " " + pvalCount + " " + deg1 + " " + deg2 + "\n");
                }
            }
        }
    }
    
    private static void writeSimplexPNASProjection(BufferedWriter output, SimplexGraph g, boolean finalize, DecimalFormat df) throws Exception {
        PNASProjection proj = (PNASProjection)g.projection;
        if (!finalize) {
            System.out.println("Finalize was selected to be false. However, PNAS weights do not support");
            System.out.println("the combination of unfinalized files at a later time. Creating finalized");
            System.out.println("output file instead.");
        }
        output.append("id1 id2 cooc newmanCooc expcooc sim cos pearson pvalue zscore newpear hypergeom deg1 deg2\n");
        
        /* create difference between observed and expected graph
         * compute norm of all actor vector for this new graph*/
        proj.finalizeAdjacencyMatrix();                             // compute observed adjacency matrix minus expected adjacency matrix
        Hypergeometric hyp = new Hypergeometric(g.randomSeed);
        
        /* compute constant factor for expected newman cooc
         * as (<deg^2>-<deg>)/<deg> 
         * for degrees on the event side */
        int[] eventDegs = new int[g.eventCount];    // locate memory for event dgrees 
        for (int[] alist : g.adjList) {             // iterate over the adjacency list
            for (int e : alist) {
                eventDegs[e]++;                     // and increase degree for each event
            }
        }
        // then compute the constant factor
        double newmanConst = 0;
        int deg = 0;
        for (int d : eventDegs) {                   // for all events
            newmanConst += Math.pow(d, 2);          // sum over square of degree
            deg += d;                               // and degree
        }
        newmanConst = (newmanConst - (double)deg) / (double)deg;
        
        for (int ac1 = 0; ac1 < g.actorCount; ac1++) {                        // for all actor nodes
            int r = 0;                                                        // start at the beginning of their cooc list
            int c = 0;
            while (r < proj.result[ac1].length) {                             // and while its end is not reached
                int ac2 = (int)proj.result[ac1][r++];
                int initCooc = proj.result[ac1][r++];
                double pvalue = ((double)(proj.result[ac1][r++]))/g.samples;  // compute p-value
                long coocSum = proj.coocs[ac1][c++];
                long coocSquares = proj.coocs[ac1][c++];
                int deg1 = g.degrees[ac1];
                int deg2 = g.degrees[ac2];
                double n = (double)g.eventCount;

                double sim = (double)initCooc - (deg1*deg2)/n;                // preliminary sim, still needs to be divided by eventcount
                double pear = sim / Math.sqrt(deg1*deg2*(1 - deg1/n)*(1 - deg2/n));
                sim = sim / n;                                                // finalize sim
                double expCooc = ((double)(coocSum))/g.samples;
                double lev = (double)initCooc - expCooc;
                double zscore = lev/Math.sqrt( ((double)coocSquares)/g.samples - Math.pow(expCooc,2) );
                double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
                double cos = initCooc/degProduct;
                double newpear = 0;
                for (int e=0; e<g.eventCount; e++) {
                    newpear += proj.cmatrix[ac1][e] * proj.cmatrix[ac2][e];   // compute the scalar product of both actor vectors                 
                }
                newpear = newpear / (proj.norm[ac1] * proj.norm[ac2]);        // and divide by product of norms
                double hyper = hyp.getHyperGeomSimilarity(deg1, deg2, initCooc, g.eventCount);
                double newmanCooc = (deg1*deg2*newmanConst) / g.edgeCount;
                
                output.append(g.actorMap[ac1] + " " + g.actorMap[ac2] + " ");
                output.append(initCooc+" "+df.format(newmanCooc)+" "+df.format(expCooc)+" "+df.format(sim)+" "+df.format(cos)+" "+df.format(pear)+" "+df.format(pvalue)+" "+df.format(zscore)+" "+df.format(newpear)+" "+df.format(hyper)+" "+deg1+" "+deg2+"\n");
            }
        }
    }
    
    private static void writeSimplexPvalueProjection(BufferedWriter output, SimplexGraph g, boolean finalize, DecimalFormat df) throws Exception {
        int walks = g.samples;
        PvalueSimplexProjection proj = (PvalueSimplexProjection)g.projection;
        if (finalize) output.append("id1 id2 pvalue\n");
        else output.append("id1 id2 pvalue_count\n");
        for (int a = 0; a < g.actorCount; a++) {                        // for all actor nodes
            int c = 0;                                                  // start at the beginning of their cooc list
            while (c < proj.result[a].length) {                         // and while its end is not reached
                String writePval;
                if (finalize) writePval = df.format(((double)(proj.result[a][c+2]))/walks);     // compute p-value
                else writePval = Integer.toString(proj.result[a][c+2]);                         // or get pvalue count
                int b = proj.result[a][c];                                                      // get ID of second actor
                output.append(g.actorMap[a] + " " + g.actorMap[b] + " " + writePval +"\n");     // and append to file
                c += 3;                                                 // then advance to next position in cooc list
            }
        }
    }
    
    private static void writeDuplexPvalueProjection(BufferedWriter output, DuplexGraph g, boolean finalize, DecimalFormat df) throws Exception {
        int walks = g.samples;
        PvalueDuplexProjection proj = (PvalueDuplexProjection)g.projection;
        if (finalize) output.append("id1 id2 type pvalue\n");
        else output.append("id1 id2 type pvalue_count\n");
        for (int a = 0; a < g.actorCount; a++) {                        // for all actor nodes
            int c = 0;                                                  // start at the beginning of their ++ cooc list
            while (c < proj.resultPos[a].length) {                          // and while its end is not reached
                String writePval;
                if (finalize) writePval = df.format(((double)(proj.resultPos[a][c+2]))/walks);     // compute p-value
                else writePval = Integer.toString(proj.resultPos[a][c+2]);                         // or get pvalue count
                int b = proj.resultPos[a][c];                                                      // get ID of second actor
                output.append(g.actorMap[a] + " " + g.actorMap[b] + " ++ " + writePval +"\n");     // and append to file
                c += 3;                                                 // advance to next position in cooc list
            }
            c = 0;
            while (c < proj.resultNeg[a].length) {                          // now do the same for -- cooc list
                String writePval;
                if (finalize) writePval = df.format(((double)(proj.resultNeg[a][c+2]))/walks);     // compute p-value
                else writePval = Integer.toString(proj.resultNeg[a][c+2]);                         // or get pvalue count
                int b = proj.resultNeg[a][c];
                output.append(g.actorMap[a] + " " + g.actorMap[b] + " -- " + writePval +"\n");
                c += 3;
            }
            c = 0;
            while (c < proj.resultMix[a].length) {                          // and the -+ cooc list
                String writePval;
                if (finalize) writePval = df.format(((double)(proj.resultMix[a][c+2]))/walks);     // compute p-value
                else writePval = Integer.toString(proj.resultMix[a][c+2]);                         // or get pvalue count
                int b = proj.resultMix[a][c];
                output.append(g.actorMap[a] + " " + g.actorMap[b] + " -+ " + writePval +"\n");
                c += 3;
            }
        }
    }
    
    private static void writeSimplexLeverageProjection(BufferedWriter output, SimplexGraph g, boolean finalize, DecimalFormat df) throws Exception {
        LeverageSimplexProjection proj = (LeverageSimplexProjection)g.projection;
        
        if (finalize) {
            output.append("id1 id2 leverage\n");
            int walks = g.samples;
            for (int a = 0; a < g.actorCount; a++) {                            // for all actor nodes
                int c = 0;                                                      // start at the beginning of their cooc list
                while (c < proj.result[a].length) {                             // and while its end is not reached
                    double lev = proj.result[a][c+1] - ((double)(proj.result[a][c+2]))/walks;   // compute leverage
                    int b = proj.result[a][c];                                  // get ID of second actor
                    output.append(g.actorMap[a] + " " + g.actorMap[b] + " " + df.format(lev) +"\n");       // and append to file
                    c += 3;                                                     // then advance to next position in cooc list
                }
            }
            
        } else {
            output.append("id1 id2 init_cooc cooc_count\n");
            for (int a = 0; a < g.actorCount; a++) {                            // for all actor nodes
                int c = 0;                                                      // start at the beginning of their cooc list
                while (c < proj.result[a].length) {                             // and while its end is not reached
                    int b = proj.result[a][c++];                                // get ID of second actor
                    int initCooc = proj.result[a][c++];                         // get initialCooc
                    int coocCount = proj.result[a][c++];                        // get coocCount
                    // and append everything to file
                    output.append(g.actorMap[a] + " " + g.actorMap[b] + " " + initCooc + " " + coocCount +"\n");
                }
            }
        }
    }
    
    private static void writeDuplexLeverageProjection(BufferedWriter output, DuplexGraph g, boolean finalize, DecimalFormat df) throws Exception {
        LeverageDuplexProjection proj = (LeverageDuplexProjection)g.projection;
        
        if (finalize) {
            output.append("id1 id2 type leverage\n");
            int walks = g.samples;
            for (int a = 0; a < g.actorCount; a++) {                            // for all actor nodes
                int c = 0;                                                      // start at the beginning of their ++ cooc list
                while (c < proj.resultPos[a].length) {                          // and while its end is not reached
                    double lev = proj.resultPos[a][c+1] - ((double)(proj.resultPos[a][c+2]))/walks; // compute leverage
                    int b = proj.resultPos[a][c];                               // get ID of second actor
                    output.append(g.actorMap[a] + " " + g.actorMap[b] + " ++ " + df.format(lev) +"\n");        // and append to file
                    c += 3;                                                     // then advance to next position in cooc list
                }
                c = 0;
                while (c < proj.resultNeg[a].length) {                          // now do the same for -- cooc list
                    double lev = proj.resultNeg[a][c+1] - ((double)(proj.resultNeg[a][c+2]))/walks; // compute leverage
                    int b = proj.resultNeg[a][c];                               // get ID of second actor
                    output.append(g.actorMap[a] + " " + g.actorMap[b] + " -- " + df.format(lev) +"\n");        // and append to file
                    c += 3;                                                     // then advance to next position in cooc list
                }
                c = 0;
                while (c < proj.resultMix[a].length) {                          // and the -+ cooc list
                    double lev = proj.resultMix[a][c+1] - ((double)(proj.resultMix[a][c+2]))/walks; // compute leverage
                    int b = proj.resultMix[a][c];                               // get ID of second actor
                    output.append(g.actorMap[a] + " " + g.actorMap[b] + " -+ " + df.format(lev) +"\n");        // and append to file
                    c += 3;                                                     // then advance to next position in cooc list
                }
            }
            
        } else {
            output.append("id1 id2 type init_cooc cooc_count\n");
            for (int a = 0; a < g.actorCount; a++) {                        // for all actor nodes
                int c = 0;                                                  // start at the beginning of their ++ cooc list
                while (c < proj.resultPos[a].length) {                          // and while its end is not reached
                    int b = proj.resultPos[a][c++];                             // get ID of second actor
                    int initCooc = proj.resultPos[a][c++];                      // get initialCooc
                    int coocCount = proj.resultPos[a][c++];                     // get coocCount
                    // and append everything to file
                    output.append(g.actorMap[a] + " " + g.actorMap[b] + " ++ " + initCooc + " " + coocCount +"\n");
                }
                c = 0;
                while (c < proj.resultNeg[a].length) {                          // now do the same for -- cooc list
                    int b = proj.resultNeg[a][c++];                             // get ID of second actor
                    int initCooc = proj.resultNeg[a][c++];                      // get initialCooc
                    int coocCount = proj.resultNeg[a][c++];                     // get coocCount
                    // and append everything to file
                    output.append(g.actorMap[a] + " " + g.actorMap[b] + " -- " + initCooc + " " + coocCount +"\n");
                }
                c = 0;
                while (c < proj.resultMix[a].length) {                          // and the -+ cooc list
                    int b = proj.resultMix[a][c++];                             // get ID of second actor
                    int initCooc = proj.resultMix[a][c++];                      // get initialCooc
                    int coocCount = proj.resultMix[a][c++];                     // get coocCount
                    // and append everything to file
                    output.append(g.actorMap[a] + " " + g.actorMap[b] + " -+ " + initCooc + " " + coocCount +"\n");
                }
            }
        }
    }
    
    /**
     * Reads previously computed projections from files and merges them by
     * computing final weights.
     * @param dir input directory containing projection files
     * @throws Exception
     */
    public static void mergeFiles(File dir) throws Exception {
        File[] fileList = dir.listFiles();
        int fileCount = fileList.length;
        if (fileCount == 0) {
            System.out.println("No files found in directory.");
            return;
        }
        System.out.println("Merging files.");
        BufferedReader[] input = new BufferedReader[fileCount];
        for (int i=0; i<fileCount; i++) {
            input[i] = new BufferedReader(new FileReader(fileList[i]));
        }
        
        String outfileName = "merged_" + new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date()) + ".txt";
        BufferedWriter output = new BufferedWriter(new FileWriter(new File(dir.getPath() + File.separator + outfileName)));
        String line;
        HashSet<String> set = new HashSet<String>();
        boolean error = false;
        boolean isSimplex = true;
        String weightType = null;
        int walks = 0;
        int precision = Integer.MAX_VALUE;
        
        // read past line 1 as there is nothing in it
        for (int i=0; i<fileCount; i++) input[i].readLine();
        output.append("#One-mode projection data generated by VertexVortex\n");
        
        // read line 2 and find out what type of projection was done
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            set.add(line);
        }
        if (set.contains("simplex") && set.size()==1) isSimplex = true;
        else if (set.contains("duplex") && set.size()==1) isSimplex = false;
        else error = true;
        if (error) {
            System.out.println("Warning: Unable to conclusively determine type (simplex/duplex)");
            error = false;
        }
        output.append("#" + type + ((isSimplex) ? ": simplex" : ": duplex") + "\n");
        
        // read line 3 and check if weight types match
        set.clear();
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            set.add(line);
        }
        if (set.size() != 1) error = true;
        for (String str : set) weightType = str;
        output.append("#" + weights + ":");
        for (String str : set) output.append(" " + str);
        output.append("\n");
        if (error) {
            System.out.println("Warning: not all weight types were a match.");
            error = false;
        }
        
        // read line 4 to check if any of the files were finalized
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            if (Boolean.parseBoolean(line)) error = true;
        }
        if (error) {
            System.out.println("Warning: Some input files may already be finalized.");
            error = false;
        }
        output.append("#" + finalized + ": true\n");
        
        // read line 5 and compare source files
        set.clear();
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            set.add(line);
        }
        if (set.size() != 1) error = true;
        output.append("#" + sourceFile + ":");
        for (String str : set) output.append(" " + str);
        output.append("\n");
        if (error) {
            System.out.println("Warning: not all original input files were a match.");
            error = false;
        }
        
        // read past line 6 as it only contains the date
        for (int i=0; i<fileCount; i++) input[i].readLine();
        output.append("#" + time + ": " + new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date()) +"\n");
        
        // read line 7 and check if projection sides match
        set.clear();
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            set.add(line);
        }
        if (set.size() != 1) error = true;
        output.append("#" + side + ":");
        for (String str : set) output.append(" " + str);
        output.append("\n");
        if (error) {
            System.out.println("Warning: not all projection sides were a match.");
            error = false;
        }
        
        // read line 8 and extract sample sizes
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            walks += Integer.parseInt(line);
        }
        output.append("#" + samples + ": " + walks + "\n");
        
        // read line 9 and check if step counts match
        set.clear();
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            set.add(line);
        }
        if (set.size() != 1) error = true;
        output.append("#" + steps + ":");
        for (String str : set) output.append(" " + str);
        output.append("\n");
        if (error) {
            System.out.println("Warning: not all step counts were a match.");
            error = false;
        }
        
        // read line 10 and check if random seeds are not identical
        set.clear();
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            set.add(line);
        }
        if (set.size() != fileCount) error = true;
        output.append("#" + seed + ":");
        for (String str : set) output.append(" " + str);
        output.append("\n");
        if (error) {
            System.out.println("Warning: some random seeds were identical.");
            error = false;
        }
        
        // read line 11 and compare the precisions
        set.clear();
        for (int i=0; i< fileCount; i++) {
            line = input[i].readLine();
            line = line.substring(line.indexOf(":")+2);
            set.add(line);
        }
        if (set.size() > 1) {
            error = true;
        }
        for (String prec : set) {
            int p = Integer.parseInt(prec);
            if (p < precision) precision = p;
        }
        // create decimal format according to the number of decimal places set by the user
        if (precision < 1) precision = 1;                       // no less than one decimal place
        if (precision > 14) precision = 14;                     // but no more than 14
        String precFormat = "0.0";
        for (int i=1; i<precision; i++) precFormat += "#";
        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);
        symbols.setInfinity("Inf");
        symbols.setNaN("NaN");
        DecimalFormat df = new DecimalFormat(precFormat, symbols);
        output.append("#" + decPrecision + ": " + precision + "\n");
        if (error) {
            System.out.println("Warning: different decimal precisions specified. Using minimum.");
            error = false;
        }
        
        // read past line 12 as it only contains column labels
        for (int i=0; i<fileCount; i++) input[i].readLine();
        
        // read and compare the lines containing data, for each compute the final weights
        if (weightType.equals("pvalue")) {
            // write line 12 for p-values
            if (isSimplex) output.append("id1 id2 pvalue\n");
            else output.append("id1 id2 type pvalue\n");
            mergePvalueProjection(output, input, fileList, walks, df);
        } else if (weightType.equals("leverage")) {
         // write line 12 for leverage
            if (isSimplex) output.append("id1 id2 leverage\n");
            else output.append("id1 id2 type leverage\n");
            mergeLeverageProjection(output, input, fileList, walks, df);
        } else if (weightType.equals("all")) {
            // write line 12 for all
            if (isSimplex) output.append("id1 id2 sim cos cooc lev lift pvalue zscore smin smax sav deg1 deg2\n");
            else output.append("id1 id2 type sim cos cooc lev lift pvalue zscore smin smax sav deg1 deg2\n");
            mergeAllProjection(output, input, fileList, walks, df);            
            
        } else {
            System.out.println("No merger method implemented for weight type " + weightType + ".");
        }
        
        System.out.println("Merging complete.");
        
        for (int i=0; i< fileCount; i++) {
            if ((line = input[i].readLine()) != null) error = true;
        }
        if (error) System.out.println("Warning: not all files had the same length.");
        
        for (int i=0; i< fileCount; i++) input[i].close();
        output.close();        
    }
    
    private static void mergeAllProjection(BufferedWriter output, BufferedReader[] input, File[] fileList, int walks, DecimalFormat df) throws Exception {
        int lineCount = 12;
        int fileCount = fileList.length;
        String line;
        while ((line = input[0].readLine()) != null) {
            lineCount++;
            String[] splitline = line.split(" ");
            int deg2 = Integer.parseInt(splitline[splitline.length-1]);
            int deg1 = Integer.parseInt(splitline[splitline.length-2]);
            int pvalCount = Integer.parseInt(splitline[splitline.length-3]);
            long coocSquares = Long.parseLong(splitline[splitline.length-4]);
            long coocCount = Long.parseLong(splitline[splitline.length-5]);
            int initCooc = Integer.parseInt(splitline[splitline.length-6]);
            double cos = Double.parseDouble(splitline[splitline.length-7]);
            double sim = Double.parseDouble(splitline[splitline.length-8]);
            String edgeName = "";
            for (int i=0; i<splitline.length-8; i++) edgeName += splitline[i];
            for (int i=1; i<fileCount; i++) {
                line = input[i].readLine();
                splitline = line.split(" ");
                String edgeName2 = "";
                for (int j=0; j<splitline.length-8; j++) edgeName2 += splitline[j];
                if (edgeName.equals(edgeName2)) {
                    pvalCount += Integer.parseInt(splitline[splitline.length-3]);
                    coocSquares += Long.parseLong(splitline[splitline.length-4]);
                    coocCount += Long.parseLong(splitline[splitline.length-5]);
                } else {
                    System.out.println("Mismatching edges on line " + lineCount);
                    System.out.println(fileList[0].getName() + ": " + edgeName);
                    System.out.println(fileList[i].getName() + ": " + edgeName2);
                    System.out.println("Aborting.");
                    return;
                }
            }
            
            double expCooc = ((double)(coocCount))/walks;
            double lev = (double)initCooc - expCooc;
            double lift = (double)initCooc / expCooc;
            double zscore = lev/Math.sqrt( ((double)coocSquares)/walks - Math.pow(expCooc,2) );
            double smin = lev/Math.min(deg1, deg2);
            double smax = lev/Math.max(deg1, deg2);
            double degProduct = Math.sqrt(deg1) * Math.sqrt(deg2);
            double sav = lev/degProduct;
            double pvalue = ((double)(pvalCount))/walks;
            
            for (int i=0; i<splitline.length-8; i++) output.append(splitline[i] + " ");
            output.append(df.format(sim)+" "+df.format(cos)+" "+initCooc+" "+df.format(lev)+" "+df.format(lift)+" "+df.format(pvalue)+" "+df.format(zscore)+" "+df.format(smin)+" "+df.format(smax)+" "+df.format(sav)+" "+deg1+" "+deg2+"\n");
        }
    }
    
    private static void mergePvalueProjection(BufferedWriter output, BufferedReader[] input, File[] fileList, int walks, DecimalFormat df) throws Exception {
        int lineCount = 12;
        int fileCount = fileList.length;
        String edgeName;
        String line;
        while ((line = input[0].readLine()) != null) {
            lineCount++;
            int pos = line.lastIndexOf(" ");
            edgeName = line.substring(0, pos);
            double value = Double.parseDouble(line.substring(pos+1));
            for (int i=1; i<fileCount; i++) {
                line = input[i].readLine();
                pos = line.lastIndexOf(" ");
                if (edgeName.equals(line.substring(0, pos))) {
                    value += Double.parseDouble(line.substring(pos+1));
                } else {
                    System.out.println("Mismatching edges on line " + lineCount);
                    System.out.println(fileList[0].getName() + ": " + edgeName);
                    System.out.println(fileList[i].getName() + ": " + line.substring(0, pos));
                    System.out.println("Aborting.");
                    return;
                }
            }
            output.append(edgeName + " " + df.format(value/walks) + "\n");
        }
    }

    private static void mergeLeverageProjection(BufferedWriter output, BufferedReader[] input, File[] fileList, int walks, DecimalFormat df) throws Exception {
        int lineCount = 12;
        int fileCount = fileList.length;
        String line;
        while ((line = input[0].readLine()) != null) {
            lineCount++;
            String[] splitline = line.split(" ");
            double coocCount = Integer.parseInt(splitline[splitline.length-1]);
            double initCooc = Integer.parseInt(splitline[splitline.length-2]);
            String edgeName = "";
            for (int i=0; i<splitline.length-1; i++) edgeName += splitline[i];
            for (int i=1; i<fileCount; i++) {
                line = input[i].readLine();
                splitline = line.split(" ");
                String edgeName2 = "";
                for (int j=0; j<splitline.length-1; j++) edgeName2 += splitline[j];
                if (edgeName.equals(edgeName2)) {
                    coocCount += Integer.parseInt(splitline[splitline.length-1]);
                } else {
                    System.out.println("Mismatching edges on line " + lineCount);
                    System.out.println(fileList[0].getName() + ": " + edgeName);
                    System.out.println(fileList[i].getName() + ": " + edgeName2);
                    System.out.println("Aborting.");
                    return;
                }
            }
            for (int i=0; i<splitline.length-2; i++) output.append(splitline[i] + " ");
            output.append(df.format((initCooc-coocCount/walks)) + "\n");
        }
    }


}
